import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import net.darkhax.curseforgegradle.TaskPublishCurseForge
import net.darkhax.curseforgegradle.UploadArtifact
import org.apache.groovy.json.internal.LazyMap

plugins {
    id 'eclipse'
    id 'idea'
    id 'maven-publish'
    id 'net.minecraftforge.gradle' version '[6.0,6.2)'
    id 'com.modrinth.minotaur' version '2.+'
    id 'net.darkhax.curseforgegradle' version '1.1.18'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
}

version = mod_version
group = mod_group_id

base {
    archivesName = mod_id
    }

java.toolchain.languageVersion = JavaLanguageVersion.of(8)

println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"
minecraft {
    mappings channel: mapping_channel, version: mapping_version
 
    copyIdeResources = true

    runs {
        configureEach {
            workingDirectory project.file('run')

            property 'forge.logging.markers', 'REGISTRIES'

            property 'forge.logging.console.level', 'debug'

            mods {
                "${mod_id}" {
                    source sourceSets.main
                }
            }
        }
        client {
            workingDirectory project.file('run/client')
            property 'forge.enabledGameTestNamespaces', mod_id
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

        }

        client2 {
            workingDirectory project.file('run/client2')
            args '--username', 'Dev3'
            property 'forge.enabledGameTestNamespaces', mod_id
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
        }

        server {
            workingDirectory project.file('run/server')
            property 'forge.enabledGameTestNamespaces', mod_id
            property 'mixin.env.remapRefMap', 'true'
            property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"

            args '--nogui'
        }

        data {
            workingDirectory project.file('run-data')

            args '--mod', mod_id, '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')
        }
    }
}

sourceSets.main.resources { srcDir 'src/generated/resources' }

repositories {
    maven { url "https://cursemaven.com"}
    maven {
        url = 'https://maven.parchmentmc.org'
    }
}

configurations {
    shade
    implementation.extendsFrom shade
}

dependencies {
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

    implementation fg.deobf("curse.maven:dcintegration-324952:4933515")
    implementation fg.deobf("curse.maven:mine-mine-no-mi-78726:7170763")
}

tasks.named('processResources', ProcessResources).configure {
    var replaceProperties = [
            minecraft_version           : minecraft_version, 
            minecraft_version_range     : minecraft_version_range,
            forge_version               : forge_version, 
            forge_version_range         : forge_version_range,
            loader_version_range        : loader_version_range,
            mod_id                      : mod_id, 
            mod_name                    : mod_name, 
            mod_license                 : mod_license, 
            mod_version                 : mod_version,
            mod_authors                 : mod_authors, 
            mod_description             : mod_description, 
            modrinth_changelog          : modrinth_changelog,
            modrinth_version_type       : modrinth_version_type
    ]
    inputs.properties replaceProperties

    filesMatching(['META-INF/mods.toml', 'pack.mcmeta']) {
        expand replaceProperties + [project: project]
    }
}

tasks.named('jar', Jar).configure {
    manifest {
        attributes([
                'Specification-Title'     : mod_id,
                'Specification-Vendor'    : mod_authors,
                'Specification-Version'   : '1', // We are version 1 of ourselves
                'Implementation-Title'    : project.name,
                'Implementation-Version'  : project.jar.archiveVersion,
                'Implementation-Vendor'   : mod_authors,
                'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            artifact jar
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/mcmodsrepo"
        }
        flatDir {
            dirs 'libs'
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}


/**********************  Custom stuff I wrote for automation  **********************/

enum ChangelogType {
    PATCH, MINOR, MAJOR
}

enum VersionType {
    release, alpha, beta
}

private void updateModVersion(String latestVersion, VersionType versionType) {
    def gradlePropertiesFile = file('gradle.properties')
    def gradleProperties = new Properties()

    gradleProperties.load(new FileInputStream(gradlePropertiesFile))
    gradleProperties.setProperty('mod_version', latestVersion)
    gradleProperties.setProperty('upload_version_type', versionType.toString())
    gradleProperties.store(gradlePropertiesFile.newWriter(), null)

    logger.lifecycle("Updated mod_version to ${latestVersion} and upload_version_type to ${versionType}")
}

private void updateUploadChangelog(String latestVersion, VersionType versionType) {
    String changelogFolder = "./changelogs"
    String lookupName = "${changelogFolder}/${latestVersion.replace(".", "-")}-${versionType.toString()}.md"
    File changelogFile = file(lookupName)

    def gradlePropertiesFile = file('gradle.properties')
    def gradleProperties = new Properties()

    gradleProperties.load(new FileInputStream(gradlePropertiesFile))
    gradleProperties.setProperty('upload_changelog', changelogFile.text)
    gradleProperties.store(gradlePropertiesFile.newWriter(), null)

}

private void addNewChangelogEntry(Object updateObject, String latestVersion, String changelogMessage) {
    LazyMap changelogEntries = updateObject."${this.minecraft_version}"
    changelogEntries.put(latestVersion, changelogMessage)
    changelogEntries.sort()

    updateObject."${this.minecraft_version}" = changelogEntries
}

private void updatePromos(Object updateObject, ChangelogType changelogType, VersionType versionType) {
    String latestVersion = updateObject.promos."${minecraft_version}-latest"

    Integer latestVersionMajor = Integer.valueOf(latestVersion[0])
    Integer latestVersionMinor = Integer.valueOf(latestVersion[2])
    Integer latestVersionPatch = Integer.valueOf(latestVersion[4])

    switch (changelogType) {
        case ChangelogType.PATCH:
            latestVersionPatch += 1
            break
        case ChangelogType.MINOR:
            latestVersionMinor += 1
            latestVersionPatch = 0
            break
        case ChangelogType.MAJOR:
            latestVersionMajor += 1
            latestVersionMinor = 0
            latestVersionPatch = 0
            break
        default:
            throw new IllegalArgumentException("Unknown changelog type: ${changelogType}")
    }

    String newVersion = "${latestVersionMajor}.${latestVersionMinor}.${latestVersionPatch}"
    updateObject.promos."${minecraft_version}-latest" = newVersion
    if (versionType == VersionType.release) {
        updateObject.promos."${minecraft_version}-recommended" = newVersion
    }
}

private String updateUpdatesJson(String changelogMessage, ChangelogType changelogType, VersionType versionType) {
    logger.lifecycle("Reading changelog environment variable")
    if (changelogMessage == null || changelogMessage.isEmpty()) {
        throw new IllegalStateException("CHANGELOG_MESSAGE environment variable must be set")
    }

    logger.lifecycle("Reading updates.json file")
    File updatesFile = file('updates.json')

    JsonSlurper jsonSlurper = new JsonSlurper()
    Object updateObject = jsonSlurper.parse(updatesFile)

    logger.lifecycle("Updating promos")
    this.updatePromos(updateObject, changelogType, versionType)

    String latestVersion = updateObject.promos."${minecraft_version}-latest"
    logger.lifecycle("Adding new changelog entry")
    this.addNewChangelogEntry(updateObject, latestVersion, changelogMessage)

    JsonBuilder jsonBuilder = new JsonBuilder(updateObject)
    String jsonString = jsonBuilder.toPrettyString()
    logger.lifecycle("Writing updates.json file")
    updatesFile.text = jsonString
    logger.lifecycle("Successfully updated updates.json with new version: ${latestVersion}")

    return latestVersion
}

tasks.register('updateProperties') {
    doLast {
        logger.lifecycle("Reading changelog from environment")
        String changelogMessage = System.getenv('CHANGELOG_MESSAGE')
        logger.lifecycle("Reading version type from environment")
        VersionType versionType = VersionType.valueOf(System.getenv('VERSION_TYPE'))
        logger.lifecycle("Reading changelog type from environment")
        ChangelogType changelogType = ChangelogType.valueOf(System.getenv('CHANGELOG_TYPE'))

        logger.lifecycle("Updating updates.json with changelog message: ${changelogMessage}, changelog type: ${changelogType}, version type: ${versionType}")
        String latestVersion = this.updateUpdatesJson(changelogMessage, changelogType, versionType)

        logger.lifecycle("Updating upload changelog")
        this.updateUploadChangelog(latestVersion, versionType)

        logger.lifecycle("Updating mod version and type")
        this.updateModVersion(latestVersion, versionType)
    }
}

modrinth {
    token = System.getenv('MODRINTH_TOKEN')
    projectId = findProperty('mod_id').toString()
    versionNumber = findProperty('mod_version').toString()
    versionType = findProperty('upload_version_type').toString()
    changelog = findProperty('upload_changelog').toString()
    uploadFile = jar
    gameVersions = [minecraft_version.toString()]
    syncBodyFrom = file('README.md').text
    dependencies {
        required.project 'dcintegration'
        required.project 'mine-mine-no-mi'
    }
}
tasks.modrinth.dependsOn(tasks.modrinthSyncBody)

tasks.register('publishCurseForge', TaskPublishCurseForge) {
    apiToken = System.getenv('CURSEFORGE_TOKEN')

    UploadArtifact mainFile = upload(findProperty('curseforge_id'), jar)
    mainFile.changelog = findProperty('upload_changelog')
    mainFile.changelogType = 'markdown'
    mainFile.releaseType = findProperty('upload_version_type')
    mainFile.addRequirement('mine-mine-no-mi')
    mainFile.addRequirement('dcintegration')
    mainFile.addGameVersion("${minecraft_version}")
    mainFile.addModLoader('Forge')
}
